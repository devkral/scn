
"""
scn_client_node=None


@app.route('/server/<server>')
@app.route('/server/<server>/<name>')
@app.route('/server/<server>/<name>/<service>')
@app.route('/server')
@app.route('/')
def generate_server_nav(server=None,name=None,service=None):
  if "Klsls" in scn_client_node.clientactions_bool:
    scn_client_node.c_info(server)
    return template("server_nav",server=server,name=name,service=service,return_state=None,return_list=None)
  elif "Klsls" in scn_client_node.clientactions_list:
    scn_client_node.c_info(server)
    return template("server_nav",server=server,name=name,service=service,return_state=None,return_list=None)
  else:
    return template("server_nav",server=server,name=name,service=service,return_state=None,return_list=None)


@app.route('/friends/<node>')
@app.route('/friends')
def generate_client_nav(node=None):
  return template("client_nav",node=node,return_state=None,return_list=None)

@app.route('/actions/<action>')
def do_action(action):
  pass

@app.route('/static/:path#.+#')
def server_static(path):
    return static_file(path, root=curdir+'/static')


#def do_action(action,server):
#    return template('<b>Hello {{name}}</b>!', name=name)
"""

def scn_send(_string,_socket):
  temp=bytes(_string,"utf-8")
  start=0
  while start < len(temp):
    _socket.sendall(scn_format.pack(temp[start:start+buffersize]))
    start+=buffersize
  _socket.sendall(scn_format.pack(temp[start:start+buffersize-(len(temp)%buffersize)]))

def scn_send_bytes(_byteseq,_socket,end=False):
  len_byte_seq=len(_byteseq)
  _socket.sendall(scn_format.pack(b"bytes"+bytes(sepc,"utf8")+bytes(str(len_byte_seq),"utf8")+bytes(sepc,"utf8")))
  _socket.setblocking(True)
  is_accepting=str(_socket.recv(buffersize),"utf8").replace("\0","").replace("\n","")
  print(is_accepting)
  if is_accepting=="y":
    temp_format_bytes=struct.Struct(">"+str(buffersize+1)+"s")
    if end==False:
      _socket.sendall(temp_format_bytes.pack(_byteseq+bytes(sepc)))
    else:
      _socket.sendall(temp_format_bytes.pack(_byteseq+bytes(sepm)))
    print("FInisisi")
    #_socket.setblocking(False)
    return True
  else:
    return False



def scn_receive(_socket,max_ob_size=max_normal_size):
  _buffer=""
  temp=[]
  for protcount in range(0,protcount_max):
    #cleanup buffer
    _buffer=_buffer.replace("\n","").replace("\0","")
    #split buffer
    if len(_buffer)>0:
      if _buffer[-1]==sepc:
        temp+=_buffer.split(sepc)[:-1]
        _buffer=""
      else:
        #if sepm, buffer ends with sepm
        temp+=_buffer.split(sepc)[:-1]
        _buffer=_buffer.split(sepc)[-1]
    #case bytewise transfer
    print(_buffer)
    print(temp)
    if len(temp)>=2 and temp[-2]=="bytes":
      print("byteiiii")
      _socket.setblocking(True)
      try:
        _size=int(temp[-1])
      except Exception as e:
        printdebug("Bytesequence: Conversion into len (Int) failed")
        printdebug(e)
        try:
          print("answered")
          _socket.sendall(b"n")
        except Exception:
          pass
        return None
      try:
        if _size<max_ob_size:
          
          print("answered")
          _socket.sendall(b"y")
          scn_format2=struct.Struct(">"+str(_size)+"s")
          temp2=_socket.recv(_size)
          #check if size fits
          if len(temp2)==_size:
            temp=temp[:-2]+[scn_format2.unpack(temp2)[0],]
          else:
            printerror("Bytesequence: Incorrect size")
            printerror(temp2)
            return None
          #because ssl sockets support no peek
          checkif_sepm=_socket.recv(buffersize)
          if checkif_sepm==bytes(sepm):
            return temp
          elif checkif_sepm==bytes(sepc):
            pass
          else:
            printdebug("Bytesequence: should be closed with either sepc or sepm")
        else:
          printdebug("Bytesequence: too big")
          _socket.sendall(b"n")

      except socket.timeout or SSL.WantReadError:
        printerror("Bytesequence: Timeout or SSL.WantReadError")
        return None
      except Exception as e:
        printerror("Bytesequence: error while receiving")
        printerror(e)
        return None
      print("bytes over")
    
    if _buffer!="" and _buffer.find(sepm)!=-1:
      break

    try:
      temp3=_socket.recv(buffersize)
    except socket.timeout or SSL.WantReadError:
      printdebug("Command: Timeout or SSL.WantReadError")
      return None
    except Exception as e:
      printerror("Command: error while receiving")
      printerror(e)
      return None
    
    if len(temp3)==buffersize:
      _buffer+=scn_format.unpack(temp3)[0].decode("utf-8")
    else:
      printerror("Main: Invalid size:"+str(len(temp3)))
      printerror(temp3)
      return None
  temp+=[_buffer.split(sepm,1)[0],] #sepm should be end, if not don't care
  return temp




"""
  printdebug("Publiccert doesn't exist. Generate new")
  success=False
  _cert = crypto.X509()
  _cert.get_subject().CN = "scn.node"
  _cert.set_issuer(_cert.get_subject())
  _cert.set_version(0)
  _cert.add_extensions([
    crypto.X509Extension(b"basicConstraints", True, b"CA:TRUE, pathlen:0"),
    crypto.X509Extension(b"keyUsage", True, b"keyCertSign, cRLSign"),
    crypto.X509Extension(b"subjectKeyIdentifier", False, b"hash", subject=_cert), ])
  _cert.add_extensions([
    crypto.X509Extension(b"authorityKeyIdentifier", False, b"keyid:always",issuer=_cert),])

  _cert.set_pubkey(_key)
  #TODO: expose hash choice
  _cert.sign(_key, "sha512")
  with open(_path+".pub", 'wb') as writeout:
    writeout.write(crypto.dump_certificate(crypto.FILETYPE_PEM,_cert))
    success=True
  return success"""







"""
  _key = crypto.PKey()
  _key.generate_key(crypto.TYPE_RSA,key_size)
  privkey=None
  if _passphrase==None:
    privkey=crypto.dump_privatekey(crypto.FILETYPE_PEM,_key)
  else:
    #TODO: expose cipher choice
    privkey=crypto.dump_privatekey(crypto.FILETYPE_PEM,_key,"CAMELLIA256",_passphrase)
  with open(_path+".priv", 'wb') as writeout:
    writeout.write(privkey)
    os.chmod(_path+".priv",0o700)
  try:
    os.remove(_path+".pub")
  except FileNotFoundError:
    pass
  check_certs(_path,_passphrase)"""


def scn_unpack(_packedbytes):
  return scn_format.unpack(_packedbytes).decode("utf-8")

def scn_pack_bytes(_byteseq):
  return scn_format.pack(bytes(_byteseq))

def scn_unpack_bytes(_packedbytes):
  return scn_format.unpack(_packedbytes)


#just already available buffer means no []
def scn_receive_old(_socket,max_ob_size=max_normal_size):
  rettemp=[]
  try:
    _buffer=_socket.recv(4)
  except socket.timeout:
    return None
  except Exception as e:
    printdebug (e)
    return None
  while len(_buffer)>0 and _buffer[-1]!=bytes(sepm,"utf8"):
    if _buffer[-1]==bytes(sepc,"utf8"):
      rettemp+=[_buffer[:-1].decode("utf8"),]
      _buffer=b""
      if len(rettemp)>=2 and rettemp[-2]=="bytes":
        if int(rettemp[-1])>0 and int(rettemp[-1])<max_ob_size:
          _socket.sendall(b"y")
          rettemp=rettemp[:-2]+[_socket.recv(rettemp[-1]).decode("utf8"),]
        else:
          _socket.sendall(b"n")
    elif _buffer[-1]==b"\n" or _buffer[-1]==b"\0":
      _buffer=_buffer[:-1]
    try:
      _buffer+=_socket.recv(1)
    except socket.timeout:
      return None
    except Exception as e:
      printdebug (e)
      return None
  rettemp+=[_buffer[:-1],]
  return rettemp

  def update_friend_auth_send(self,_socket,_name,_old_key,_pubkey_new):
    tempkey2=RSA.importKey(_old_key)
    signer=PKCS1_PSS.new(tempkey2)
    _name_hashed=hashlib.SHA256(_stamp)
    if not verifier.verify(_name_hashed,_signed_stamp): 
      return False
    if scn_friends.update_friend(_name,_pubkey):
      scn_send("success"+sepm,_socket)
    else:
      scn_send("error"+sepc+"auth"+sepm,_socket)


#pub auth
  def update_friend_auth_recv(self,_socket,_name,_pubkey_new,_signed_stamp,_stamp):
    if _pubkey_new==b"":
      scn_send("error"+sepc+"key empty"+sepm,_socket)
      return
    _old_key=self.scn_friends.get_pubkey(self,_name)
    if _old_key==None:
      scn_send("error"+sepc+"name not exist"+sepm,_socket)
      return
    
    tempkey2=RSA.importKey(_old_key)
    verifier=PKCS1_PSS.new(tempkey2)
    _name_hashed=hashlib.SHA256(_stamp)
    if not verifier.verify(_name_hashed,_signed_stamp): 
      return False
    if scn_friends.update_friend(_name,_pubkey):
      scn_send("success"+sepm,_socket)
    else:
      scn_send("error"+sepc+"auth"+sepm,_socket)


  def parse_return(self,reqreturn):
    temp=reqreturn.split(sepc,1)
    if temp[0]=="error" and len(temp)==2:
      print("Error: "+temp[1])
      return None
    elif temp[0]=="success" and len(temp)==2:
      return temp[1].split(sepc)
    else:
      print("Error: invalid message")
      return None

#scn_friends: _nameid: pubkey,nickname
class scn_friend_list_template(self):
  friend_list=None
  def __init__(self):
    serv_list={}
  def create_friend(self,_proposedname,_pubkey,nickname=None):
    if _proposedname in self.friend_list:
      count=1
      while _proposedname+str(count) in self.friend_list:
        count+=1
    self.friend_list[_proposedname+str(count)]=[_pubkey,nickname]
    return _proposedname+str(count)
  def update_friend(self,_nameid,_pubkey,nickname=None):
    self.friend_list[_nameid][0]=_pubkey
    if nickname!=None:
      self.friend_list[_nameid][1]=nickname
    return True
  def delete_friend(self,_nameid):
    if _name in self.friend_list:
      del self.friend_list[_nameid]
      return True
    else:
      return False
  def get_pubkey(self,_nameid):
    if _name in self.friend_list:
      return self.friend_list[_name][1]
    else:
      return None